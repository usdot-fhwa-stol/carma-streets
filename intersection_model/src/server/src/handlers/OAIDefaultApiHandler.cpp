/**
 * Intersection Model API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QVariantMap>
#include <QDebug>

#include "OAIDefaultApiHandler.h"
#include "OAIDefaultApiRequest.h"


namespace OpenAPI {

OAIDefaultApiHandler::OAIDefaultApiHandler(std::shared_ptr<intersection_model::intersection_model> &model){
 this->int_worker = model;
}

OAIDefaultApiHandler::~OAIDefaultApiHandler(){

}

void OAIDefaultApiHandler::getConflictLanelets(qint32 link_lanelet_id) {
    Q_UNUSED(link_lanelet_id);
    auto reqObj = qobject_cast<OAIDefaultApiRequest*>(sender());
    if( reqObj != nullptr )
    {
        QList<OAILanelet_info> res;
        //Only return the conflict lanelet ids when input is a link lanelet within an intersection
        if(int_worker->is_valid_link_lanelet_id(link_lanelet_id))
        {
            std::vector<intersection_model::lanelet_info_t>  link_lanelet_v = int_worker->get_conflict_lanelets(link_lanelet_id);
            for(std::vector<intersection_model::lanelet_info_t>::iterator itr = link_lanelet_v.begin(); itr != link_lanelet_v.end();itr++)
            {
                OAILanelet_info lanelet_info;
                lanelet_info.setId (itr->id);
                lanelet_info.setSpeedLimit(itr->speed_limit);
                lanelet_info.setLength(itr->length);
                res.push_back(lanelet_info);
            }        
            reqObj->getConflictLaneletsResponse(res);            
        }
        else
        {
            QString err_msg = "Invalid link lanelet id parameter.";
            reqObj->getConflictLaneletsError(res, QNetworkReply::NetworkError::ContentAccessDenied, err_msg);
        }             
    }
}
void OAIDefaultApiHandler::getIntersectionInfo() {
    auto reqObj = qobject_cast<OAIDefaultApiRequest*>(sender());
    if( reqObj != nullptr )
    {
        OAIIntersection_info res;
        res.setId(int_worker->get_intersection_info().intersection_id);
        res.setName(int_worker->get_intersection_info().intersection_name.c_str());
        QList<OAILanelet_info> departure_lanlets;
        intersection_model::intersection_info_t  int_info = int_worker->get_intersection_info();
        for(std::set<intersection_model::lanelet_info_t>::iterator itr = int_info.departure_lanelets.begin(); itr != int_info.departure_lanelets.end();itr++)
        {
            OAILanelet_info lanelet_info;
            lanelet_info.setId (itr->id);
            lanelet_info.setSpeedLimit(itr->speed_limit);
            lanelet_info.setLength(itr->length);
            departure_lanlets.push_back(lanelet_info);
        }
        res.setDepartureLanelets(departure_lanlets);
        
        QList<OAILanelet_info> link_lanlets;
        for(std::vector<intersection_model::lanelet_info_t>::iterator itr = int_info.link_lanelets.begin(); itr != int_info.link_lanelets.end();itr++)
        {
            OAILanelet_info lanelet_info;
            lanelet_info.setId (itr->id);
            lanelet_info.setSpeedLimit(itr->speed_limit);
           
            //Update the llink lanelet_info with the list of conflict lanelets
            std::vector<intersection_model::lanelet_info_t> conflict_lanelet_info_v = int_worker->get_conflict_lanelets(itr->id);
            QList<qint32> conflict_lanelet_ids;
            for(auto conflict_itr = conflict_lanelet_info_v.begin(); conflict_itr != conflict_lanelet_info_v.end(); conflict_itr++)
            {
                conflict_lanelet_ids.push_back(conflict_itr->id);
            }
            lanelet_info.setConflictLaneletIds(conflict_lanelet_ids);
            lanelet_info.setLength(itr->length);
            link_lanlets.push_back(lanelet_info);
        }
        res.setLinkLanelets(link_lanlets);
        
        QList<OAILanelet_info> entry_lanlets;
        for(std::vector<intersection_model::lanelet_info_t>::iterator itr = int_info.entering_lanelets.begin(); itr != int_info.entering_lanelets.end();itr++)
        {
            OAILanelet_info lanelet_info;
            lanelet_info.setId (itr->id);
            lanelet_info.setSpeedLimit(itr->speed_limit);
            lanelet_info.setLength(itr->length);
            entry_lanlets.push_back(lanelet_info);
        }
        res.setEntryLanelets(entry_lanlets);
        reqObj->getIntersectionInfoResponse(res);
    }
}
void OAIDefaultApiHandler::listDepartureLanelets() {
    auto reqObj = qobject_cast<OAIDefaultApiRequest*>(sender());
    if( reqObj != nullptr )
    {
        QList<OAILanelet_info> res;
        std::set<intersection_model::lanelet_info_t>  departure_lanelet_v = int_worker->get_departure_lanelets();
        for(std::set<intersection_model::lanelet_info_t>::iterator itr = departure_lanelet_v.begin(); itr != departure_lanelet_v.end();itr++)
        {
            OAILanelet_info lanelet_info;
            lanelet_info.setId (itr->id);
            lanelet_info.setSpeedLimit(itr->speed_limit);
            lanelet_info.setLength(itr->length);
            res.push_back(lanelet_info);
        }
        reqObj->listDepartureLaneletsResponse(res);
    }
}
void OAIDefaultApiHandler::listEntryLanelets() {
    auto reqObj = qobject_cast<OAIDefaultApiRequest*>(sender());
    if( reqObj != nullptr )
    {
        QList<OAILanelet_info> res;
        std::vector<intersection_model::lanelet_info_t>  entry_lanelet_v = int_worker->get_entry_lanelets();
        for(std::vector<intersection_model::lanelet_info_t>::iterator itr = entry_lanelet_v.begin(); itr != entry_lanelet_v.end();itr++)
        {
            OAILanelet_info lanelet_info;
            lanelet_info.setId (itr->id);
            lanelet_info.setSpeedLimit(itr->speed_limit);
            lanelet_info.setLength(itr->length);
            res.push_back(lanelet_info);
        }
        reqObj->listEntryLaneletsResponse(res);
    }
}
void OAIDefaultApiHandler::listLinkLanelets() {
    auto reqObj = qobject_cast<OAIDefaultApiRequest*>(sender());
    if( reqObj != nullptr )
    {
        QList<OAILanelet_info> res;
        std::vector<intersection_model::lanelet_info_t>  link_lanelet_v = int_worker->get_link_lanelets();
        for(std::vector<intersection_model::lanelet_info_t>::iterator itr = link_lanelet_v.begin(); itr != link_lanelet_v.end();itr++)
        {
            OAILanelet_info lanelet_info;
            lanelet_info.setId (itr->id);
            lanelet_info.setSpeedLimit(itr->speed_limit);
            lanelet_info.setLength(itr->length);
            res.push_back(lanelet_info);
        }
        reqObj->listLinkLaneletsResponse(res);
    }
}


}
